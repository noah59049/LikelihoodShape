#!/usr/bin/env python

# In order to have our example matrices be realistic, we are generating them from an actual logistic regression model on the sklearn breast cancer dataset

import numpy as np
import sklearn
from sklearn.datasets import load_breast_cancer
from sklearn.linear_model import LogisticRegression
import statsmodels.api as sm

#Some useful helper methods
def as_row(vec):
    return vec.reshape(1,-1)
def as_col(vec):
    return vec.reshape(-1,1)

COLS_TO_KEEP = 4
colnames = list(load_breast_cancer().feature_names[0:COLS_TO_KEEP])
X, y = load_breast_cancer(return_X_y=True)
X = X[:,0:COLS_TO_KEEP]
yX = np.hstack([as_col(y.astype(X.dtype)), X])

# Turns a numpy tensor into TeX which is nice for displaying.
# Generated by ChatGPT, modified by Noah
def numpy_to_latex(
    arr: np.ndarray,
    sigfigs: int = 4,
    max_rows: int = -1, # -1 automatically calculates
    max_cols: int = -1, # -1 automatically calculates
    tail_rows: int = 2,
    tail_cols: int = 2,
    make_table: bool = False,
    colnames: list[str] = []
) -> str:
    if not isinstance(arr, np.ndarray):
        raise TypeError("Input must be a numpy.ndarray")

    if arr.ndim >= 3:
        raise ValueError("Array must be 1D or 2D")

    # Treat 1D arrays as column vectors
    if arr.ndim == 1:
        arr = as_col(arr)

    n_rows, n_cols = arr.shape
    
    # If automatically calculating max_rows or max_cols, do so here
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))
    
    if max_rows == -1:
        max_rows = display_size(n_rows)
    if max_cols == -1:
        max_cols = display_size(n_cols)

    if tail_rows < 0 or tail_cols < 0:
        raise ValueError("tail_rows and tail_cols must be nonnegative")

    def format_entry(x):
        try:
            x = float(x)
            return f"{x:.{sigfigs}g}"
        except (ValueError, TypeError):
            return str(x)

    def indices(n, max_n, tail_n):
        if n <= max_n:
            return list(range(n)), False

        if tail_n + 1 >= max_n:
            raise ValueError("tail_n is too large relative to max_n")

        head_n = max_n - tail_n - 1
        idx = list(range(head_n)) + list(range(n - tail_n, n))
        return idx, True

    row_idx, row_trunc = indices(n_rows, max_rows, tail_rows)
    col_idx, col_trunc = indices(n_cols, max_cols, tail_cols)

    if colnames:
        rows = [" & ".join(colnames) + "\n"]
    else:
        rows = []

    for i in row_idx:
        entries = []
        for j in col_idx:
            entries.append(format_entry(arr[i, j]))

        if col_trunc:
            # Insert horizontal ellipsis before the tail columns
            insert_at = len(entries) - tail_cols
            entries.insert(insert_at, r"\ldots")

        rows.append(" & ".join(entries))

    if row_trunc:
        ellipsis_row = []
        displayed_cols = len(col_idx) + (1 if col_trunc else 0)
        if make_table:
            ellipsis_row = [r"$\vdots$"] * displayed_cols
        else:
            ellipsis_row = [r"\vdots"] * displayed_cols

        if col_trunc:
            ellipsis_col = len(ellipsis_row) - tail_cols - 1
            ellipsis_row[ellipsis_col] = r"$\ddots$" if make_table else r"\ddots" 

        # Insert ellipsis row before the tail rows
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, " & ".join(ellipsis_row))

    if make_table:
        body = " \\\\\n\\hline\n    ".join(rows)
        body = f"\\hline\n{body} \\\\\n\\hline\n"
    else:
        body = " \\\\\n    ".join(rows)

    # Check that every column has the same number of "&" because otherwise LaTeX will complain
    if True:
        expected_cols = None
        for r in rows:
            count = r.count("&")
            if expected_cols is None:
                expected_cols = count
            elif count != expected_cols:
                raise RuntimeError("Inconsistent column count in LaTeX matrix")

    
    if make_table:
        header_text = "|" + " c |" * max_cols
        return (
            f"\\begin{{tabular}}{{ {header_text} }}\n"
            f"    {body}\n"
            "\\end{tabular}"
        )
    else:
        return (
            "\\begin{bmatrix}\n"
            f"    {body}\n"
            "\\end{bmatrix}"
        )

x_names = [f"X{i + 1}" for i, e in enumerate(colnames)]
yX_tex_numbered = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + x_names)}$"
yX_tex = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + colnames)}$"
y_tex = f"${numpy_to_latex(y, make_table = True, colnames = ['Y'])}$"
y_labels_tex = y_tex.replace("0", "Malignant").replace("1", "Benign").replace("Y", "Breast Cancer")
# ------------------------------
# Now actually animate the scene
# ------------------------------

from manim import *
from MF_Tools import *

class DefinitionsScene(Scene):
    def construct(self):
        y_labels_table = Tex(y_labels_tex).scale(0.6)
        y_labels_table.shift(LEFT * y_labels_table.width * 1.4)
        y_table = Tex(y_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table = Tex(yX_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table_numbered = Tex(yX_tex_numbered).scale(0.6).align_to(y_labels_table, UL)
        self.play(Write(y_labels_table))
        self.play(TransformMatchingShapes(y_labels_table, y_table))
        self.play(FadeIn(yX_table))
        self.remove(y_table)
        self.play(TransformMatchingShapes(yX_table, yX_table_numbered))

if __name__ == "__main__":
    print(yX_tex)