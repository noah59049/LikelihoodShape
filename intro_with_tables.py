# In order to have our example matrices be realistic, we are generating them from an actual logistic regression model on the sklearn breast cancer dataset

import numpy as np
import pandas as pd
# from sklearn.datasets import load_breast_cancer
# from sklearn.linear_model import LogisticRegression
# import statsmodels.api as sm

#Some useful helper methods
def as_row(vec):
    return vec.reshape(1,-1)
def as_col(vec):
    return vec.reshape(-1,1)

COLS_TO_KEEP = 4 # If we set this to a different number it would minorly break things
"""
colnames = list(load_breast_cancer().feature_names[0:COLS_TO_KEEP])
X, y = load_breast_cancer(return_X_y=True)
X = X[:,0:COLS_TO_KEEP]
yX = np.hstack([as_col(y.astype(X.dtype)), X])
"""
df = pd.read_csv("breast_cancer_sklearn.csv")
colnames = list(df.columns[0:COLS_TO_KEEP])
X = np.array(df[colnames])
y = np.array(df["target"])
yX = np.hstack([as_col(y.astype(X.dtype)), X])


# Turns a numpy tensor into TeX which is nice for displaying.
# Generated by ChatGPT, modified by Noah
def numpy_to_latex(
    arr: np.ndarray,
    sigfigs: int = 4,
    max_rows: int = -1, # -1 automatically calculates
    max_cols: int = -1, # -1 automatically calculates
    tail_rows: int = 2,
    tail_cols: int = 2,
    make_table: bool = False,
    colnames: list[str] = []
) -> str:
    if not isinstance(arr, np.ndarray):
        raise TypeError("Input must be a numpy.ndarray")

    if arr.ndim >= 3:
        raise ValueError("Array must be 1D or 2D")

    # Treat 1D arrays as column vectors
    if arr.ndim == 1:
        arr = as_col(arr)

    n_rows, n_cols = arr.shape
    
    # If automatically calculating max_rows or max_cols, do so here
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))
    
    if max_rows == -1:
        max_rows = display_size(n_rows)
    if max_cols == -1:
        max_cols = display_size(n_cols)

    if tail_rows < 0 or tail_cols < 0:
        raise ValueError("tail_rows and tail_cols must be nonnegative")

    def format_entry(x):
        try:
            x = float(x)
            return f"{x:.{sigfigs}g}"
        except (ValueError, TypeError):
            return str(x)

    def indices(n, max_n, tail_n):
        if n <= max_n:
            return list(range(n)), False

        if tail_n + 1 >= max_n:
            raise ValueError("tail_n is too large relative to max_n")

        head_n = max_n - tail_n - 1
        idx = list(range(head_n)) + list(range(n - tail_n, n))
        return idx, True

    row_idx, row_trunc = indices(n_rows, max_rows, tail_rows)
    col_idx, col_trunc = indices(n_cols, max_cols, tail_cols)

    if colnames:
        rows = [" & ".join(colnames) + "\n"]
    else:
        rows = []

    for i in row_idx:
        entries = []
        for j in col_idx:
            entries.append(format_entry(arr[i, j]))

        if col_trunc:
            # Insert horizontal ellipsis before the tail columns
            insert_at = len(entries) - tail_cols
            entries.insert(insert_at, r"\ldots")

        rows.append(" & ".join(entries))

    if row_trunc:
        ellipsis_row = []
        displayed_cols = len(col_idx) + (1 if col_trunc else 0)
        if make_table:
            ellipsis_row = [r"$\vdots$"] * displayed_cols
        else:
            ellipsis_row = [r"\vdots"] * displayed_cols

        if col_trunc:
            ellipsis_col = len(ellipsis_row) - tail_cols - 1
            ellipsis_row[ellipsis_col] = r"$\ddots$" if make_table else r"\ddots" 

        # Insert ellipsis row before the tail rows
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, " & ".join(ellipsis_row))

    if make_table:
        body = " \\\\\n\\hline\n    ".join(rows)
        body = f"\\hline\n{body} \\\\\n\\hline\n"
    else:
        body = " \\\\\n    ".join(rows)

    # Check that every column has the same number of "&" because otherwise LaTeX will complain
    if True:
        expected_cols = None
        for r in rows:
            count = r.count("&")
            if expected_cols is None:
                expected_cols = count
            elif count != expected_cols:
                raise RuntimeError("Inconsistent column count in LaTeX matrix")

    
    if make_table:
        header_text = "|" + " c |" * max_cols
        return (
            f"\\begin{{tabular}}{{ {header_text} }}\n"
            f"    {body}\n"
            "\\end{tabular}"
        )
    else:
        return (
            "\\begin{bmatrix}\n"
            f"    {body}\n"
            "\\end{bmatrix}"
        )

x_names = [f"X{i + 1}" for i, e in enumerate(colnames)]
yX_tex_numbered = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + x_names)}$"
yX_lines = yX_tex_numbered.split(r"\hline")
yX_tex = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + colnames)}$"
y_tex = f"${numpy_to_latex(y, make_table = True, colnames = ['Y'])}$"
y_labels_tex = y_tex.replace("0", "Malignant").replace("1", "Benign").replace("Y", "Breast Cancer")
# ------------------------------
# Now actually animate the scene
# ------------------------------

from manim import *
from manim_voiceover import VoiceoverScene
from MF_Tools import *
from manim_voiceover.services.stitcher import _StitcherService as StitcherService

class DefinitionsScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(StitcherService("/Users/noah/Convex/LikelihoodShape/intro_with_tables.mp3",
                cache_dir="/Users/noah/Convex/LikelihoodShape/cache_dir",
                min_silence_len=2000))

        # Part 1: The tables

        y_labels_table = Tex(y_labels_tex).scale(0.6)
        y_labels_table.shift(LEFT * y_labels_table.width * 1.4)
        y_table = Tex(y_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table = Tex(yX_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table_numbered = Tex(yX_tex_numbered).scale(0.6).align_to(y_labels_table, UL)
        with self.voiceover(text = "We have a variable we're interested in predicting, and it's dichotomous." \
                                    "It can only take on two different values." \
                                    "And we have a bunch of individual observations of that variable" \
                                    "Here we're using data from a real dataset, it's called the " \
                                    "Breast Cancer Wisconsin dataset") as tracker:
            self.play(Write(y_labels_table))
        with self.voiceover("This variable can be called your dependent variable or your response variable" \
                            "or many other names. We call it Y, "
                            "and we pick one of the values to be 0 and another to be 1" \
                            "Here 0 is malignant and 1 is benign") as tracker:
            self.play(TransformMatchingShapes(y_labels_table, y_table))
        with self.voiceover("And we have one or more other variables that we think are related" \
                            "to our response variable. We likewise have one value of each variable"
                            " for each individual. These are sometimes called explanatory variables" \
                            "or predictor variables or independent variables." \
                            "Unlike the response variable, these can be any real number.") as tracker:
            self.play(FadeIn(yX_table))
            self.remove(y_table)
        with self.voiceover("We notate these variables as X1, X2, and so on") as tracker:
            self.play(TransformMatchingShapes(yX_table, yX_table_numbered))
        self.play(FadeOut(yX_table_numbered))

        # Part 2: Odds definition
        odds1 = MathTex(r"Odds=\frac{p}{1-p}")
        odds2 = Text("The odds of winning are 3 to 1.")
        logodds1 = MathTex(r"\ln\frac{p}{1-p}")
        logodds2 = MathTex(r"\ln\frac{p}{1-p}=\beta_0+\beta_1 X_1+\beta_2 X_2+\ldots+\beta_{k-1} X_{k-1}")
        logodds3 = MathTex(r"\ln\frac{p_i}{1-p_i}=\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1}")
        plugin1 = MathTex(r"\ln\frac{p_i}{1-p_i}=\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\beta_3 X_{i,3}+\beta_4 X_{i,4}")
        plugin2 = MathTex(r"\ln\frac{p_1}{1-p_1}=\beta_0+\beta_1 X_{1,1}+\beta_2 X_{1,2}+\beta_3 X_{1,3}+\beta_4 X_{1,4}").to_edge(DOWN)

        with self.voiceover(text = "The main assumption of logistic regression is that the log odds of Y being 1 is equal to a linear combination of the Xs, like this") as tracker:
            self.play(Write(logodds2))

        with self.voiceover(text = "That's a big equation, so let's look at the individual parts of it") as tracker:
            pass

        with self.voiceover(text = "In the context of statistics, the odds of something are the probability of it happening divided by the probability of it not happening."
        "In other words, if the probability of something is p, the odds of it are p over 1-p") as tracker:
            self.play(TransformByGlyphMap(logodds2, odds1,
                                          (range(7,33),[]),
                                          (range(2,7), range(5,10)),
                                           ([0,1],[]),
                                           ([],[0,1,2,3,4])))

        self.play(FadeOut(odds1))
        with self.voiceover(text = "suppose we're on a sports team, and I say the odds of winning are 3 to 1") as tracker:
            self.add(odds2)
        with self.voiceover("This means we are 3 times as likely to win as to lose") as tracker:
            self.remove(odds2)
            # self.add(Text("WWWL"))

        # TODO: Finish this explanation of odds

        with self.voiceover("Now let's manipulate this formula to isolate p_i") as tracker:
            self.add(logodds3)

        # Part 3: Transform the log odds formula into a sigmoid formula
        sigmoid1 = MathTex(r"\frac{p_i}{1-p_i}=e^{\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1}}")
        sigmoid2 = MathTex(r"\frac{1-p_i}{p_i}=e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid3 = MathTex(r"\frac{1}{p_i}-\frac{p_i}{p_i}=e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid4 = MathTex(r"\frac{1}{p_i}-1=e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid5 = MathTex(r"\frac{1}{p_i}=1+e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid6 = MathTex(r"p_i=\frac{1}{1+e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}}")
        sigmoid7 = MathTex(r"p_i=\sigma(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")

        with self.voiceover(text = "We exponentiate both sides, and this cancels out the ln") as tracker:
            # This would have been a simple TransformByGlyphMap(logodds3, sigmoid1)
            # But that was warping/twisting some glyphs.
            # So we have a rigid transformation of the glyphs we don't want to twist, which is more annoying
            x_src_idx = range(10,41) #[15, 16, 22, 23, 35, 36]
            x_dst_idx = range(9,40) #[14, 15, 21, 22, 34, 35]
            x_src = VGroup(*[logodds3[0][i] for i in x_src_idx])
            x_dst = VGroup(*[sigmoid1[0][i] for i in x_dst_idx])
            rest_src = VGroup(*[
                m for i, m in enumerate(logodds3)
                if i not in x_src
            ])
            rest_dst = VGroup(*[
                m for i, m in enumerate(sigmoid1)
                if i not in x_dst
            ])
            self.play(
                TransformByGlyphMap(
                    rest_src,
                    rest_dst,
                    ([0,1],[8], {"path_arc": -PI * 0.6}),
                ),
                *[
                    x_src[i].animate.move_to(x_dst[i])
                    for i in range(len(x_src))
                ]
            )

        with self.voiceover(text = "We take the reciprocal of both sides, and the reciprocal of e to something is e to the negative of that") as tracker:
            self.play(TransformByGlyphMap(sigmoid1, sigmoid2,
                                        ([0,1],[5,6], {"path_arc": PI * 0.5}),
                                        ([3,4,5,6],[0,1,2,3], {"path_arc": PI * 0.5}),
                                        (FadeIn, [9,10]),
                                        (FadeIn,[42])))
        
        with self.voiceover(text = "and then we expand the fraction on the left hand side") as tracker:
            self.play(TransformByGlyphMap(sigmoid2, sigmoid3,
                                        ([0,4,5,6],[0,1,2,3]),
                                        ([2,3,4,5,6],[5,6,7,8,9]),
                                        ([1],[4])))
        
        with self.voiceover(text = "Simplify p_i over p_i") as tracker: # "Simplify pi over pi" causes the AI voice to sputter for 1.5 minutes, IDK why
            self.play(TransformByGlyphMap(sigmoid3, sigmoid4,
                                        ([5,6,7,8,9],[5])))
        
        with self.voiceover(text = "Add one to both sides") as tracker:
            self.play(TransformByGlyphMap(sigmoid4, sigmoid5,
                                        ([4,5],[5,6], {"path_arc": -PI}),
                                        ([6],[4], {"path_arc":-PI})))
        
        with self.voiceover(text = "Take the reciprocal again") as tracker:
            self.play(TransformByGlyphMap(sigmoid5, sigmoid6,
                                        ([0,1], [3,4])))
            
        # INTERLUDE: Defining the sigmoid
        self.remove(sigmoid6)

        # Interlude, Part 1: Sigmoid definitions
        sigmoid_defn  = MathTex(r"\sigma(z)=\frac{1}{1+e^{-z}}").to_corner(UL)
        sigmoid_defn2 = MathTex(r"\sigma(z)=\frac{(1)e^z}{(1+e^{-z})e^z}").to_corner(UL)
        sigmoid_defn3 = MathTex(r"\sigma(z)=\frac{e^z}{e^z+e^ze^{-z}}").to_corner(UL)
        sigmoid_defn4 = MathTex(r"\sigma(z)=\frac{e^z}{e^z+1}").to_corner(UL)

        # Interlude, Part 2: Graph
        axes = Axes(x_range = [-5,5,1], 
                    y_range = [-0,1,0.2],
                    ).add_coordinates()
        axis_labels = axes.get_axis_labels(x_label = "z",
                                           y_label = r"\sigma(z)")
        func = axes.plot(sigmoid, 
                         color = GREEN)
        graph_group = VGroup(axes, axis_labels, func)

        # Interlude, Part 3: The animation
        self.play(Write(sigmoid_defn))
        self.play(DrawBorderThenFill(axes), Write(axis_labels), run_time = 0.5)
        self.play(Create(func))

        self.play(TransformByGlyphMap(sigmoid_defn, sigmoid_defn2,
                                      (FadeIn, [5,7,8,9]),
                                      (FadeIn, [11,17,18,19])))
        self.play(TransformByGlyphMap(sigmoid_defn2, sigmoid_defn3,
                                      ([5,6,7], FadeOut, {"run_time": 0.25}),
                                      ([11,17],FadeOut),
                                      ([14,15,16], [13,14,15]),
                                      ([18, 19], [11,12], {"path_arc": PI}),
                                      ([12], [8,9]),
                                      ([18,19], [8,9], {"path_arc": PI})))
        self.play(TransformByGlyphMap(sigmoid_defn3, sigmoid_defn4,
                                      ([11,12,13,14,15], [11], {"run_time": 0.75})))
        self.wait(0.25)

        # Now back to the main scene
        self.remove(sigmoid_defn4)
        self.remove(axes, axis_labels, func)
        self.add(sigmoid6)
        
        with self.voiceover(text = "And we have a special name for this function on the right side: the sigmoid") as tracker:
            self.play(TransformByGlyphMap(sigmoid6, sigmoid7,
                                        ([3,4,5,6,7,8],[3], {"path_arc":PI * 0.8})))
            
        # Part 4: Applying the formula to the table

        plugin1 = MathTex(r"p_i=\sigma(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\beta_3 X_{i,3}+\beta_4 X_{i,4})")
        plugin2 = MathTex(r"p_1=\sigma(\beta_0+\beta_1 X_{1,1}+\beta_2 X_{1,2}+\beta_3 X_{1,3}+\beta_4 X_{1,4})").to_edge(DOWN)

        self.remove(sigmoid7)
        yX_table_numbered.to_corner(UL)
        sigmoid7.to_edge(DOWN)
        plugin1.to_edge(DOWN)
        with self.voiceover("So let's look at this formula, when you plug in some values from our dataset") as tracker:
            self.play(FadeIn(yX_table_numbered), FadeIn(sigmoid7))
        with self.voiceover("We have 4 independent variables in this case") as tracker:
            self.play(TransformByGlyphMap(sigmoid7, plugin1,
                                        (range(22,25),range(22,28)),
                                        (range(26,36),range(29,35))))

        # Determine the height of the rectangle
        # I don't know of a way to find the height of one row of a latex table
        # We could divide the height of the table by the number of rows
        # Except for the ellipses
        # So instead we make a table with fewer rows, then divide the height of that by the number of rows in that
        yX_head = yX[0:6,:]
        yX_head_tex = f"${numpy_to_latex(yX_head, make_table = True, colnames = ['Y'] + x_names)}$"
        yX_head_table = Tex(yX_head_tex).scale(0.6)

        # Add the highlight rectangle
        highlight_rect = Rectangle(
                            width=yX_table_numbered.width,
                            height=yX_head_table.height / 7,
                            fill_color=RED,
                            fill_opacity=0.2,     # transparency
                            stroke_width=0        # remove border
                        )
        highlight_rect.align_to(yX_table_numbered, UL)

        # Plug in i = 1
        with self.voiceover(text = "For each value of i, you get a different individual, " \
                              "a different row, and you multiply the betas by different numbers.") as tracker:
            highlight_rect.shift(DOWN * highlight_rect.height)
            self.play(FadeIn(highlight_rect))
            self.play(TransformByGlyphMap(plugin1, plugin2,
                                        ([], [])))

            def tex_for_row(i):
                return MathTex(f"p_{i}=\\sigma(\\beta_0+" + "+".join([f"\\beta_{k+1} {X[i-1,k]}" for k in range(COLS_TO_KEEP)]) + ")")
            plugin_old = plugin2
            plugin_new = tex_for_row(1).to_edge(DOWN)
            self.play(TransformMatchingTex(plugin_old, plugin_new))
            for i in range(2, 9):
                highlight_rect.shift(DOWN * highlight_rect.height)
                plugin_old = plugin_new
                plugin_new = tex_for_row(i).to_edge(DOWN)
                self.play(TransformMatchingTex(plugin_old, plugin_new))
                self.wait(1.5)

if __name__ == "__main__":
    print("\n" * 8)
    print(yX_lines[1:-1])