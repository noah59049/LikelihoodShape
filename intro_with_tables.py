#!/usr/bin/env python

# In order to have our example matrices be realistic, we are generating them from an actual logistic regression model on the sklearn breast cancer dataset

import numpy as np
import sklearn
from sklearn.datasets import load_breast_cancer
from sklearn.linear_model import LogisticRegression
import statsmodels.api as sm

#Some useful helper methods
def as_row(vec):
    return vec.reshape(1,-1)
def as_col(vec):
    return vec.reshape(-1,1)

COLS_TO_KEEP = 4
colnames = list(load_breast_cancer().feature_names[0:COLS_TO_KEEP])
X, y = load_breast_cancer(return_X_y=True)
X = X[:,0:COLS_TO_KEEP]
yX = np.hstack([as_col(y.astype(X.dtype)), X])

# Turns a numpy tensor into TeX which is nice for displaying.
# Generated by ChatGPT, modified by Noah
def numpy_to_latex(
    arr: np.ndarray,
    sigfigs: int = 4,
    max_rows: int = -1, # -1 automatically calculates
    max_cols: int = -1, # -1 automatically calculates
    tail_rows: int = 2,
    tail_cols: int = 2,
    make_table: bool = False,
    colnames: list[str] = []
) -> str:
    if not isinstance(arr, np.ndarray):
        raise TypeError("Input must be a numpy.ndarray")

    if arr.ndim >= 3:
        raise ValueError("Array must be 1D or 2D")

    # Treat 1D arrays as column vectors
    if arr.ndim == 1:
        arr = as_col(arr)

    n_rows, n_cols = arr.shape
    
    # If automatically calculating max_rows or max_cols, do so here
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))
    
    if max_rows == -1:
        max_rows = display_size(n_rows)
    if max_cols == -1:
        max_cols = display_size(n_cols)

    if tail_rows < 0 or tail_cols < 0:
        raise ValueError("tail_rows and tail_cols must be nonnegative")

    def format_entry(x):
        try:
            x = float(x)
            return f"{x:.{sigfigs}g}"
        except (ValueError, TypeError):
            return str(x)

    def indices(n, max_n, tail_n):
        if n <= max_n:
            return list(range(n)), False

        if tail_n + 1 >= max_n:
            raise ValueError("tail_n is too large relative to max_n")

        head_n = max_n - tail_n - 1
        idx = list(range(head_n)) + list(range(n - tail_n, n))
        return idx, True

    row_idx, row_trunc = indices(n_rows, max_rows, tail_rows)
    col_idx, col_trunc = indices(n_cols, max_cols, tail_cols)

    if colnames:
        rows = [" & ".join(colnames) + "\n"]
    else:
        rows = []

    for i in row_idx:
        entries = []
        for j in col_idx:
            entries.append(format_entry(arr[i, j]))

        if col_trunc:
            # Insert horizontal ellipsis before the tail columns
            insert_at = len(entries) - tail_cols
            entries.insert(insert_at, r"\ldots")

        rows.append(" & ".join(entries))

    if row_trunc:
        ellipsis_row = []
        displayed_cols = len(col_idx) + (1 if col_trunc else 0)
        if make_table:
            ellipsis_row = [r"$\vdots$"] * displayed_cols
        else:
            ellipsis_row = [r"\vdots"] * displayed_cols

        if col_trunc:
            ellipsis_col = len(ellipsis_row) - tail_cols - 1
            ellipsis_row[ellipsis_col] = r"$\ddots$" if make_table else r"\ddots" 

        # Insert ellipsis row before the tail rows
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, " & ".join(ellipsis_row))

    if make_table:
        body = " \\\\\n\\hline\n    ".join(rows)
        body = f"\\hline\n{body} \\\\\n\\hline\n"
    else:
        body = " \\\\\n    ".join(rows)

    # Check that every column has the same number of "&" because otherwise LaTeX will complain
    if True:
        expected_cols = None
        for r in rows:
            count = r.count("&")
            if expected_cols is None:
                expected_cols = count
            elif count != expected_cols:
                raise RuntimeError("Inconsistent column count in LaTeX matrix")

    
    if make_table:
        header_text = "|" + " c |" * max_cols
        return (
            f"\\begin{{tabular}}{{ {header_text} }}\n"
            f"    {body}\n"
            "\\end{tabular}"
        )
    else:
        return (
            "\\begin{bmatrix}\n"
            f"    {body}\n"
            "\\end{bmatrix}"
        )

x_names = [f"X{i + 1}" for i, e in enumerate(colnames)]
yX_tex_numbered = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + x_names)}$"
yX_lines = yX_tex_numbered.split(r"\hline")
yX_tex = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + colnames)}$"
y_tex = f"${numpy_to_latex(y, make_table = True, colnames = ['Y'])}$"
y_labels_tex = y_tex.replace("0", "Malignant").replace("1", "Benign").replace("Y", "Breast Cancer")
# ------------------------------
# Now actually animate the scene
# ------------------------------

from manim import *
from manim_voiceover import VoiceoverScene
from MF_Tools import *
from manim_voiceover.services.coqui import CoquiService


class DefinitionsScene(VoiceoverScene):
    def construct(self):
        # Part 1: The tables
        y_labels_table = Tex(y_labels_tex).scale(0.6)
        y_labels_table.shift(LEFT * y_labels_table.width * 1.4)
        y_table = Tex(y_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table = Tex(yX_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table_numbered = Tex(yX_tex_numbered).scale(0.6).align_to(y_labels_table, UL)
        self.play(Write(y_labels_table))
        self.play(TransformMatchingShapes(y_labels_table, y_table))
        self.play(FadeIn(yX_table))
        self.remove(y_table)
        self.play(TransformMatchingShapes(yX_table, yX_table_numbered))
        self.play(FadeOut(yX_table_numbered))

        # Part 2: Odds definition
        self.set_speech_service(CoquiService())

        p1 = MathTex(r"P(y=1)")
        p2 = MathTex(r"p")
        odds1 = MathTex(r"Odds")
        odds2 = MathTex(r"Odds = \frac{p}{1-p}")
        logodds1 = MathTex(r"\ln\frac{p}{1-p}")
        logodds2 = MathTex(r"\ln\frac{p}{1-p}=\beta_0+\beta_1 X_1+\beta_2 X_2+\ldots+\beta_{k-1} X_{k-1}")
        logodds3 = MathTex(r"\ln\frac{p_i}{1-p_i}=\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1}")

        with self.voiceover(text = "We are trying to look at how the probability that y is 1 depends on the Xs") as tracker:
            self.play(Write(p1))
        with self.voiceover(text = "So we denote that as p") as tracker:
            self.play(ReplacementTransform(p1, p2))
        self.play(FadeOut(p2))
        with self.voiceover(text = "Instead of directly looking at probability, we look at the odds. Now, people often use probability and odds interchangeably,"
                            "but here we mean odds in the sense where it's the probability of an event happening divided by the probability of it not happening"
                            "And you might have heard the term odds used in this sense. If someone says the odds of such and such event are 3 to 1,"
                            "They probably mean it's 3 times as likely to happen as not to happen, and this corresponds to a probability of 3/4") as tracker:
            self.play(FadeIn(odds1))
        with self.voiceover(text = "So we represent odds as p over 1 minus p") as tracker:
            self.play(TransformByGlyphMap(odds1, odds2,
                (FadeIn, range(4,10))))
        with self.voiceover(text = "So we actually look at the log odds, or just the ln of the odds") as tracker:
            self.play(TransformByGlyphMap(odds2, logodds1,
                ([0,1,2,3,4],[0,1])))
        with self.voiceover(text = "And the big assumption of logistic regression is that the log odds is equal to a linear combination of the Xs") as tracker:
            self.play(TransformByGlyphMap(logodds1, logodds2,
                (FadeIn, range(7, 33), {"delay":0.5, "run_time":1.4})))

        with self.voiceover(text = "And then we are looking at the Eye-Ith individual, so we subscript the p and the Xs with i") as tracker:
            self.play(TransformByGlyphMap(logodds2, logodds3,
                (FadeIn, [3]),
                (FadeIn, [8]),
                (FadeIn, [16,17]),
                (FadeIn, [23, 24]),
                (FadeIn, [36, 37])))
            
        # Part 3: Applying the formula to the table
        self.remove(logodds3)
        yX_table_numbered.to_corner(UL)
        logodds3.to_edge(DOWN)
        self.play(FadeIn(yX_table_numbered), FadeIn(logodds3))
        

        # Determine the height of the rectangle
        # I don't know of a way to find the height of one row of a latex table
        # We could divide the height of the table by the number of rows
        # Except for the ellipses
        # So instead we make a table with fewer rows, then divide the height of that by the number of rows in that
        yX_head = yX[0:6,:]
        yX_head_tex = f"${numpy_to_latex(yX_head, make_table = True, colnames = ['Y'] + x_names)}$"
        yX_head_table = Tex(yX_head_tex).scale(0.6)

        # Add the highlight rectangle
        highlight_rect = Rectangle(
                            width=yX_table_numbered.width,
                            height=yX_head_table.height / 7,
                            fill_color=RED,
                            fill_opacity=0.2,     # transparency
                            stroke_width=0        # remove border
                        )
        highlight_rect.align_to(yX_table_numbered, UL)

        


if __name__ == "__main__":
    print("\n" * 8)
    print(yX_lines[1:-1])