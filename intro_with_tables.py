# In order to have our example matrices be realistic, we are generating them from an actual logistic regression model on the sklearn breast cancer dataset

import numpy as np
import sklearn
from sklearn.datasets import load_breast_cancer
from sklearn.linear_model import LogisticRegression
import statsmodels.api as sm

#Some useful helper methods
def as_row(vec):
    return vec.reshape(1,-1)
def as_col(vec):
    return vec.reshape(-1,1)

COLS_TO_KEEP = 4 # If we set this to a different number it would minorly break things
colnames = list(load_breast_cancer().feature_names[0:COLS_TO_KEEP])
X, y = load_breast_cancer(return_X_y=True)
X = X[:,0:COLS_TO_KEEP]
yX = np.hstack([as_col(y.astype(X.dtype)), X])

# Turns a numpy tensor into TeX which is nice for displaying.
# Generated by ChatGPT, modified by Noah
def numpy_to_latex(
    arr: np.ndarray,
    sigfigs: int = 4,
    max_rows: int = -1, # -1 automatically calculates
    max_cols: int = -1, # -1 automatically calculates
    tail_rows: int = 2,
    tail_cols: int = 2,
    make_table: bool = False,
    colnames: list[str] = []
) -> str:
    if not isinstance(arr, np.ndarray):
        raise TypeError("Input must be a numpy.ndarray")

    if arr.ndim >= 3:
        raise ValueError("Array must be 1D or 2D")

    # Treat 1D arrays as column vectors
    if arr.ndim == 1:
        arr = as_col(arr)

    n_rows, n_cols = arr.shape
    
    # If automatically calculating max_rows or max_cols, do so here
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))
    
    if max_rows == -1:
        max_rows = display_size(n_rows)
    if max_cols == -1:
        max_cols = display_size(n_cols)

    if tail_rows < 0 or tail_cols < 0:
        raise ValueError("tail_rows and tail_cols must be nonnegative")

    def format_entry(x):
        try:
            x = float(x)
            return f"{x:.{sigfigs}g}"
        except (ValueError, TypeError):
            return str(x)

    def indices(n, max_n, tail_n):
        if n <= max_n:
            return list(range(n)), False

        if tail_n + 1 >= max_n:
            raise ValueError("tail_n is too large relative to max_n")

        head_n = max_n - tail_n - 1
        idx = list(range(head_n)) + list(range(n - tail_n, n))
        return idx, True

    row_idx, row_trunc = indices(n_rows, max_rows, tail_rows)
    col_idx, col_trunc = indices(n_cols, max_cols, tail_cols)

    if colnames:
        rows = [" & ".join(colnames) + "\n"]
    else:
        rows = []

    for i in row_idx:
        entries = []
        for j in col_idx:
            entries.append(format_entry(arr[i, j]))

        if col_trunc:
            # Insert horizontal ellipsis before the tail columns
            insert_at = len(entries) - tail_cols
            entries.insert(insert_at, r"\ldots")

        rows.append(" & ".join(entries))

    if row_trunc:
        ellipsis_row = []
        displayed_cols = len(col_idx) + (1 if col_trunc else 0)
        if make_table:
            ellipsis_row = [r"$\vdots$"] * displayed_cols
        else:
            ellipsis_row = [r"\vdots"] * displayed_cols

        if col_trunc:
            ellipsis_col = len(ellipsis_row) - tail_cols - 1
            ellipsis_row[ellipsis_col] = r"$\ddots$" if make_table else r"\ddots" 

        # Insert ellipsis row before the tail rows
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, " & ".join(ellipsis_row))

    if make_table:
        body = " \\\\\n\\hline\n    ".join(rows)
        body = f"\\hline\n{body} \\\\\n\\hline\n"
    else:
        body = " \\\\\n    ".join(rows)

    # Check that every column has the same number of "&" because otherwise LaTeX will complain
    if True:
        expected_cols = None
        for r in rows:
            count = r.count("&")
            if expected_cols is None:
                expected_cols = count
            elif count != expected_cols:
                raise RuntimeError("Inconsistent column count in LaTeX matrix")

    
    if make_table:
        header_text = "|" + " c |" * max_cols
        return (
            f"\\begin{{tabular}}{{ {header_text} }}\n"
            f"    {body}\n"
            "\\end{tabular}"
        )
    else:
        return (
            "\\begin{bmatrix}\n"
            f"    {body}\n"
            "\\end{bmatrix}"
        )

x_names = [f"X{i + 1}" for i, e in enumerate(colnames)]
yX_tex_numbered = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + x_names)}$"
yX_lines = yX_tex_numbered.split(r"\hline")
yX_tex = f"${numpy_to_latex(yX, make_table = True, colnames = ['Y'] + colnames)}$"
y_tex = f"${numpy_to_latex(y, make_table = True, colnames = ['Y'])}$"
y_labels_tex = y_tex.replace("0", "Malignant").replace("1", "Benign").replace("Y", "Breast Cancer")
# ------------------------------
# Now actually animate the scene
# ------------------------------

from manim import *
from manim_voiceover import VoiceoverScene
from MF_Tools import *
from manim_voiceover.services.coqui import CoquiService


class DefinitionsScene(VoiceoverScene):
    def construct(self):
        self.set_speech_service(CoquiService())

        # Part 1: The tables

        y_labels_table = Tex(y_labels_tex).scale(0.6)
        y_labels_table.shift(LEFT * y_labels_table.width * 1.4)
        y_table = Tex(y_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table = Tex(yX_tex).scale(0.6).align_to(y_labels_table, UL)
        yX_table_numbered = Tex(yX_tex_numbered).scale(0.6).align_to(y_labels_table, UL)
        with self.voiceover(text = "We have a variable we're interested in predicting, and it's dichotomous." \
                                    "It can only take on two different values." \
                                    "And we have a bunch of individual observations of that variable" \
                                    "Here we're using data from a real dataset, it's called the " \
                                    "Breast Cancer Wisconsin dataset") as tracker:
            self.play(Write(y_labels_table))
        with self.voiceover("This variable can be called your dependent variable or your response variable" \
                            "or many other names. We call it Y, "
                            "and we pick one of the values to be 0 and another to be 1" \
                            "Here 0 is malignant and 1 is benign") as tracker:
            self.play(TransformMatchingShapes(y_labels_table, y_table))
        with self.voiceover("And we have one or more other variables that we think are related" \
                            "to our response variable. We likewise have one value of each variable"
                            " for each individual. These are sometimes called explanatory variables" \
                            "or predictor variables or independent variables." \
                            "Unlike the response variable, these can be any real number.") as tracker:
            self.play(FadeIn(yX_table))
            self.remove(y_table)
        with self.voiceover("We notate these variables as X1, X2, and so on") as tracker:
            self.play(TransformMatchingShapes(yX_table, yX_table_numbered))
        self.play(FadeOut(yX_table_numbered))

        # Part 2: Odds definition
        p1 = MathTex(r"P(y=1)")
        p2 = MathTex(r"p")
        odds1 = MathTex(r"Odds")
        odds2 = MathTex(r"Odds = \frac{p}{1-p}")
        logodds1 = MathTex(r"\ln\frac{p}{1-p}")
        logodds2 = MathTex(r"\ln\frac{p}{1-p}=\beta_0+\beta_1 X_1+\beta_2 X_2+\ldots+\beta_{k-1} X_{k-1}")
        logodds3 = MathTex(r"\ln\frac{p_i}{1-p_i}=\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1}")
        plugin1 = MathTex(r"\ln\frac{p_i}{1-p_i}=\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\beta_3 X_{i,3}+\beta_4 X_{i,4}")
        plugin2 = MathTex(r"\ln\frac{p_1}{1-p_1}=\beta_0+\beta_1 X_{1,1}+\beta_2 X_{1,2}+\beta_3 X_{1,3}+\beta_4 X_{1,4}").to_edge(DOWN)

        with self.voiceover(text = "We are trying to look at how the probability that y is 1 depends on the Xs") as tracker:
            self.play(Write(p1))
        with self.voiceover(text = "So we denote that as p") as tracker:
            self.play(ReplacementTransform(p1, p2))
        self.play(FadeOut(p2))
        with self.voiceover(text = "Instead of directly looking at probability, we look at the odds. Now, people often use probability and odds interchangeably,"
                            "but here we mean odds in the sense where it's the probability of an event happening divided by the probability of it not happening"
                            "And you might have heard the term odds used in this sense. If someone says the odds of such and such event are 3 to 1,"
                            "They probably mean it's 3 times as likely to happen as not to happen, and this corresponds to a probability of 3/4") as tracker:
            self.play(FadeIn(odds1))
        with self.voiceover(text = "So we represent odds as p over 1 minus p") as tracker:
            self.play(TransformByGlyphMap(odds1, odds2,
                (FadeIn, range(4,10))))
        with self.voiceover(text = "So we actually look at the log odds, or just the ln of the odds") as tracker:
            self.play(TransformByGlyphMap(odds2, logodds1,
                ([0,1,2,3,4],[0,1])))
        with self.voiceover(text = "And the big assumption of logistic regression is that the log odds is equal to a linear combination of the Xs") as tracker:
            self.play(TransformByGlyphMap(logodds1, logodds2,
                (FadeIn, range(7, 33), {"delay":0.5, "run_time":1.4})))

        with self.voiceover(text = "And then we are looking at the Eye-Ith individual, so we subscript the p and the Xs with i") as tracker:
            self.play(TransformByGlyphMap(logodds2, logodds3,
                (FadeIn, [3]),
                (FadeIn, [8]),
                (FadeIn, [16,17]),
                (FadeIn, [23, 24]),
                (FadeIn, [36, 37])))

        # Part 3: Transform the log odds formula into a sigmoid formula
        sigmoid1 = MathTex(r"\frac{p_i}{1-p_i}=e^{\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1}}")
        sigmoid2 = MathTex(r"\frac{1-p_i}{p_i}=e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid3 = MathTex(r"\frac{1}{p_i}-\frac{p_i}{p_i}=e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid4 = MathTex(r"\frac{1}{p_i}-1=e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid5 = MathTex(r"\frac{1}{p_i}=1+e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")
        sigmoid6 = MathTex(r"p_i=\frac{1}{1+e^{-(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}}")
        sigmoid7 = MathTex(r"p_i=\sigma(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\ldots+\beta_{k-1} X_{i,k-1})}")

        with self.voiceover(text = "We exponentiate both sides, and this cancels out the ln") as tracker:
            # This would have been a simple TransformByGlyphMap(logodds3, sigmoid1)
            # But that was warping/twisting some glyphs.
            # So we have a rigid transformation of the glyphs we don't want to twist, which is more annoying
            x_src_idx = range(10,41) #[15, 16, 22, 23, 35, 36]
            x_dst_idx = range(9,40) #[14, 15, 21, 22, 34, 35]
            x_src = VGroup(*[logodds3[0][i] for i in x_src_idx])
            x_dst = VGroup(*[sigmoid1[0][i] for i in x_dst_idx])
            rest_src = VGroup(*[
                m for i, m in enumerate(logodds3)
                if i not in x_src
            ])
            rest_dst = VGroup(*[
                m for i, m in enumerate(sigmoid1)
                if i not in x_dst
            ])
            self.play(
                TransformByGlyphMap(
                    rest_src,
                    rest_dst,
                    ([0,1],[8], {"path_arc": -PI * 0.6}),
                ),
                *[
                    x_src[i].animate.move_to(x_dst[i])
                    for i in range(len(x_src))
                ]
            )

        with self.voiceover(text = "We take the reciprocal of both sides, and the reciprocal of e to something is e to the negative of that") as tracker:
            self.play(TransformByGlyphMap(sigmoid1, sigmoid2,
                                        ([0,1],[5,6], {"path_arc": PI * 0.5}),
                                        ([3,4,5,6],[0,1,2,3], {"path_arc": PI * 0.5}),
                                        (FadeIn, [9,10]),
                                        (FadeIn,[42])))
        
        with self.voiceover(text = "and then we expand the fraction on the left hand side") as tracker:
            self.play(TransformByGlyphMap(sigmoid2, sigmoid3,
                                        ([0,4,5,6],[0,1,2,3]),
                                        ([2,3,4,5,6],[5,6,7,8,9]),
                                        ([1],[4])))
        
        with self.voiceover(text = "Simplify pea eye over pea eye") as tracker: # "Simplify pi over pi" causes the AI voice to sputter for 1.5 minutes, IDK why
            self.play(TransformByGlyphMap(sigmoid3, sigmoid4,
                                        ([5,6,7,8,9],[5])))
        
        with self.voiceover(text = "Add one to both sides") as tracker:
            self.play(TransformByGlyphMap(sigmoid4, sigmoid5,
                                        ([4,5],[5,6], {"path_arc": -PI}),
                                        ([6],[4], {"path_arc":-PI})))
        
        with self.voiceover(text = "Take the reciprocal again") as tracker:
            self.play(TransformByGlyphMap(sigmoid5, sigmoid6,
                                        ([0,1], [3,4])))
        
        with self.voiceover(text = "And we have a special name for this function on the right side: the sigmoid") as tracker:
            self.play(TransformByGlyphMap(sigmoid6, sigmoid7,
                                        ([3,4,5,6,7,8],[3], {"path_arc":PI * 0.8})))
            
        # Part 4: Applying the formula to the table

        plugin1 = MathTex(r"p_i=\sigma(\beta_0+\beta_1 X_{i,1}+\beta_2 X_{i,2}+\beta_3 X_{i,3}+\beta_4 X_{i,4})")
        plugin2 = MathTex(r"p_1=\sigma(\beta_0+\beta_1 X_{1,1}+\beta_2 X_{1,2}+\beta_3 X_{1,3}+\beta_4 X_{1,4})").to_edge(DOWN)

        self.remove(sigmoid7)
        yX_table_numbered.to_corner(UL)
        sigmoid7.to_edge(DOWN)
        plugin1.to_edge(DOWN)
        self.play(FadeIn(yX_table_numbered), FadeIn(sigmoid7))
        self.play(TransformByGlyphMap(sigmoid7, plugin1,
                                      (range(22,25),range(22,28)),
                                      (range(26,36),range(29,35))))

        # Determine the height of the rectangle
        # I don't know of a way to find the height of one row of a latex table
        # We could divide the height of the table by the number of rows
        # Except for the ellipses
        # So instead we make a table with fewer rows, then divide the height of that by the number of rows in that
        yX_head = yX[0:6,:]
        yX_head_tex = f"${numpy_to_latex(yX_head, make_table = True, colnames = ['Y'] + x_names)}$"
        yX_head_table = Tex(yX_head_tex).scale(0.6)

        # Add the highlight rectangle
        highlight_rect = Rectangle(
                            width=yX_table_numbered.width,
                            height=yX_head_table.height / 7,
                            fill_color=RED,
                            fill_opacity=0.2,     # transparency
                            stroke_width=0        # remove border
                        )
        highlight_rect.align_to(yX_table_numbered, UL)

        # Plug in i = 1
        highlight_rect.shift(DOWN * highlight_rect.height)
        self.play(FadeIn(highlight_rect))
        self.play(TransformByGlyphMap(plugin1, plugin2,
                                      ([], [])))

        def tex_for_row(i):
            return MathTex(f"p_{i}=\\sigma(\\beta_0+" + "+".join([f"\\beta_{k+1} {X[i-1,k]}" for k in range(COLS_TO_KEEP)]) + ")")
        plugin_old = plugin2
        plugin_new = tex_for_row(1).to_edge(DOWN)
        self.play(TransformMatchingTex(plugin_old, plugin_new))
        for i in range(2, 9):
            highlight_rect.shift(DOWN * highlight_rect.height)
            plugin_old = plugin_new
            plugin_new = tex_for_row(i).to_edge(DOWN)
            self.play(TransformMatchingTex(plugin_old, plugin_new))
            self.wait(1.5)

if __name__ == "__main__":
    print("\n" * 8)
    print(yX_lines[1:-1])