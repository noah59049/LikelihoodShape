#!/usr/bin/env python

# In order to have our example matrices be realistic, we are generating them from an actual logistic regression model on the sklearn breast cancer dataset

import numpy as np
import sklearn
from sklearn.datasets import load_breast_cancer
from sklearn.linear_model import LogisticRegression
import statsmodels.api as sm

#Some useful helper methods
def as_row(vec):
    return vec.reshape(1,-1)
def as_col(vec):
    return vec.reshape(-1,1)

X, y = load_breast_cancer(return_X_y=True)
X = sm.add_constant(X)
model1 = LogisticRegression(solver = 'lbfgs', C = np.inf, max_iter = 30000, fit_intercept = False)
result = model1.fit(X, y)
beta = as_col(model1.coef_)

# Turns a numpy tensor into TeX which is nice for displaying.
# Generated by ChatGPT, modified by Noah
def numpy_to_latex(
    arr: np.ndarray,
    sigfigs: int = 4,
    max_rows: int = -1, # -1 automatically calculates
    max_cols: int = -1, # -1 automatically calculates
    tail_rows: int = 2,
    tail_cols: int = 2,
) -> str:
    if not isinstance(arr, np.ndarray):
        raise TypeError("Input must be a numpy.ndarray")

    if arr.ndim >= 3:
        raise ValueError("Array must be 1D or 2D")

    # Treat 1D arrays as column vectors
    if arr.ndim == 1:
        arr = as_col(arr)

    n_rows, n_cols = arr.shape
    
    # If automatically calculating max_rows or max_cols, do so here
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))
    
    if max_rows == -1:
        max_rows = display_size(n_rows)
    if max_cols == -1:
        max_cols = display_size(n_cols)

    if tail_rows < 0 or tail_cols < 0:
        raise ValueError("tail_rows and tail_cols must be nonnegative")

    def format_entry(x):
        try:
            x = float(x)
            return f"{x:.{sigfigs}g}"
        except (ValueError, TypeError):
            return str(x)

    def indices(n, max_n, tail_n):
        if n <= max_n:
            return list(range(n)), False

        if tail_n + 1 >= max_n:
            raise ValueError("tail_n is too large relative to max_n")

        head_n = max_n - tail_n - 1
        idx = list(range(head_n)) + list(range(n - tail_n, n))
        return idx, True

    row_idx, row_trunc = indices(n_rows, max_rows, tail_rows)
    col_idx, col_trunc = indices(n_cols, max_cols, tail_cols)

    rows = []

    for i in row_idx:
        entries = []
        for j in col_idx:
            entries.append(format_entry(arr[i, j]))

        if col_trunc:
            # Insert horizontal ellipsis before the tail columns
            insert_at = len(entries) - tail_cols
            entries.insert(insert_at, r"\ldots")

        rows.append(" & ".join(entries))

    if row_trunc:
        ellipsis_row = []
        displayed_cols = len(col_idx) + (1 if col_trunc else 0)
        ellipsis_row = [r"\vdots"] * displayed_cols

        if col_trunc:
            ellipsis_col = len(ellipsis_row) - tail_cols - 1
            ellipsis_row[ellipsis_col] = r"\ddots"

        # Insert ellipsis row before the tail rows
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, " & ".join(ellipsis_row))

    body = " \\\\\n    ".join(rows)

    # Check that every column has the same number of "&" because otherwise LaTeX will complain
    expected_cols = None
    for r in rows:
        count = r.count("&")
        if expected_cols is None:
            expected_cols = count
        elif count != expected_cols:
            raise RuntimeError("Inconsistent column count in LaTeX matrix")

    
    return (
        "\\begin{bmatrix}\n"
        f"    {body}\n"
        "\\end{bmatrix}"
    )

def string_array_to_latex(
    data,
    max_rows: int = -1,   # -1 = automatic
    tail_rows: int = 2,
) -> str:
    # Convert input to list
    try:
        data = list(data)
    except TypeError:
        raise TypeError("Input must be a 1D iterable of strings")

    n = len(data)

    if tail_rows < 0:
        raise ValueError("tail_rows must be nonnegative")

    # Automatic display size (same philosophy as before)
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03,
    ):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))

    if max_rows == -1:
        max_rows = display_size(n)

    # Decide which indices to show
    if n <= max_rows:
        row_idx = list(range(n))
        truncated = False
    else:
        if tail_rows + 1 >= max_rows:
            raise ValueError("tail_rows too large relative to max_rows")

        head_rows = max_rows - tail_rows - 1
        row_idx = list(range(head_rows)) + list(range(n - tail_rows, n))
        truncated = True

    rows = []

    for i in row_idx:
        rows.append(str(data[i]))

    if truncated:
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, r"\vdots")

    body = " \\\\\n    ".join(rows)

    return (
        "\\begin{bmatrix}\n"
        f"    {body}\n"
        "\\end{bmatrix}"
    )

def string_array_to_table(
    data,
    max_rows: int = -1,   # -1 = automatic
    tail_rows: int = 2,
) -> str:
    # Convert input to list
    try:
        data = list(data)
    except TypeError:
        raise TypeError("Input must be a 1D iterable of strings")

    n = len(data)

    if tail_rows < 0:
        raise ValueError("tail_rows must be nonnegative")

    # Automatic display size (same philosophy as before)
    def display_size(
        n,
        full_threshold=8,
        max_display=14,
        scale=0.03,
    ):
        if n <= full_threshold:
            return n
        return min(max_display, int(full_threshold + scale * (n - full_threshold)))

    if max_rows == -1:
        max_rows = display_size(n)

    # Decide which indices to show
    if n <= max_rows:
        row_idx = list(range(n))
        truncated = False
    else:
        if tail_rows + 1 >= max_rows:
            raise ValueError("tail_rows too large relative to max_rows")

        head_rows = max_rows - tail_rows - 1
        row_idx = list(range(head_rows)) + list(range(n - tail_rows, n))
        truncated = True

    rows = []

    for i in row_idx:
        rows.append([str(data[i])])

    if truncated:
        insert_at = len(rows) - tail_rows
        rows.insert(insert_at, [r"\vdots"])

    return rows

X_str = r"$\mathbf{X}=" + f"{numpy_to_latex(X)}$"
y_str = r"$\mathbf{Y}=" + f"{numpy_to_latex(y)}$"
beta_str = r"$\mathbf{\beta}=" + f"{numpy_to_latex(beta)}$"
y_labels = [("Malignant", "Benign")[yi] for yi in y.flatten()]

# ------------------------------
# Now actually animate the scene
# ------------------------------

from manim import *

class DefinitionsScene(Scene):
    def construct(self):
        X_tex = Tex(X_str, font_size=32)
        X_tex.to_corner(UL)
        self.play(Write(X_tex))

        y_tex = Tex(y_str, font_size=32)
        y_tex.to_corner(UR)
        self.play(Write(y_tex))

        beta_tex = Tex(beta_str, font_size=32)
        beta_tex.shift(RIGHT * 3.9)
        beta_tex.to_edge(UP)
        self.play(Write(beta_tex))

        y_labels_table = Table(string_array_to_table(y_labels)).scale(0.3)
        self.play(Write(y_labels_table))
